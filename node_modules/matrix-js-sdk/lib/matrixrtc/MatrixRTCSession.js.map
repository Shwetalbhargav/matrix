{"version":3,"file":"MatrixRTCSession.js","names":["logger","rootLogger","TypedEventEmitter","EventTimeline","EventType","UpdateDelayedEventAction","CallMembership","isLegacyCallMembershipData","RoomStateEvent","randomString","secureRandomBase64Url","decodeBase64","encodeUnpaddedBase64","KnownMembership","isLivekitFocusActive","getChild","MEMBERSHIP_EXPIRY_TIME","MEMBER_EVENT_CHECK_PERIOD","CALL_MEMBER_EVENT_RETRY_DELAY_MIN","UPDATE_ENCRYPTION_KEY_THROTTLE","MAKE_KEY_DELAY","USE_KEY_DELAY","getParticipantId","userId","deviceId","concat","getParticipantIdFromMembership","m","sender","keysEqual","a","b","length","every","x","i","MatrixRTCSessionEvent","MatrixRTCSession","callId","_callId","callMembershipsForRoom","room","roomState","getLiveTimeline","getState","FORWARDS","warn","roomId","Error","callMemberEvents","getStateEvents","GroupCallMemberPrefix","callMemberships","memberEvent","content","getContent","eventKeysCount","Object","keys","membershipContents","push","Array","isArray","getSender","membershipData","_membership$sender","membership","scope","info","isExpired","hasMembershipState","Join","e","sort","createdTs","debug","map","roomSessionForRoom","client","constructor","memberships","_this","_memberships$","this","_defineProperty","Set","Map","_asyncToGenerator","keysEventUpdateTimeout","undefined","clearTimeout","lastEncryptionKeyUpdateRequest","Date","now","isJoined","getUserId","getDeviceId","myKeys","getKeysForParticipant","sendEvent","CallEncryptionKeysPrefix","key","index","device_id","call_id","encryptionKeys","error","matrixError","event","cancelPendingEvent","_matrixError$data$ret","_matrixError$data","resendDelay","data","retry_after_ms","setTimeout","sendEncryptionKeysEvent","encryptionKey","encryptionKeyIndex","setEncryptionKey","getTs","_this$_callId","_this$memberships$","oldMemberships","changed","some","equal","emit","MembershipsChanged","manageMediaKeys","makeNewKeyTimeout","oldMembershipIds","filter","isMyMembership","newMembershipIds","anyLeft","from","has","anyJoined","oldFingerprints","lastMembershipFingerprints","storeLastMembershipFingerprints","onRotateKeyTimeout","requestKeyEventSend","newFingerprints","candidateUpdates","setExpiryTimer","updateCallMembershipRunning","needCallMembershipUpdate","updateCallMembershipEvent","makeNewSenderKey","on","Members","onMembershipUpdate","relativeExpiry","stop","_this2","leaveRoomSession","expiryTimeout","memberEventTimeout","off","joinRoomSession","fociPreferred","fociActive","joinConfig","_joinConfig$manageMed","_joinConfig$useLegacy","ownFocusActive","ownFociPreferred","useLegacyMemberEvents","membershipId","triggerCallMembershipEventUpdate","JoinStateChanged","_arguments","arguments","_this3","timeout","Promise","resolve","set","t","setNewKeyTimeouts","clear","timeoutPromise","r","race","then","value","getActiveFocus","focus_selection","oldestMembership","getOldestMembership","getPreferredFoci","_this$encryptionKeys$","get","entry","getEncryptionKeys","entries","_ref3","participantId","k","values","getNewEncryptionKeyIndex","_this$getKeysForParti","_this$getKeysForParti2","encryptionKeyString","timestamp","delayBeforeUse","keyBin","participantKeys","existingKeyAtIndex","useKeyTimeout","delete","EncryptionKeyChanged","add","soonestExpiry","thisExpiry","getMsUntilExpiry","getFocusInUse","getFocusSelection","membershipID","makeMyMembershipLegacy","prevMembership","_objectSpread","application","expires","expires_ts","foci_active","created_ts","makeMyMembership","_this$ownFociPreferre","focus_active","type","foci_preferred","membershipEventNeedsUpdate","myPrevMembershipData","myPrevMembership","expiryTime","makeNewMembership","makeNewLegacyMemberships","localDeviceId","myCallMemberEvent","filterExpired","membershipObj","transformMemberships","newMemberships","_this4","localUserId","events","legacy","stateEventsContainOngoingLegacySession","newContent","_myCallMemberEvent$ge","find","stateKey","makeMembershipStateKey","sendStateEvent","res","_unstable_sendDelayedStateEvent","delay","scheduleDelayDisconnection","delay_id","Math","random","delayId","delayDisconnection","_this5","_unstable_updateDelayedEvent","Restart","size","containsAnyOngoingSession","containsUnknownOngoingSession","callMemberEvent","exec","getVersion"],"sources":["../../src/matrixrtc/MatrixRTCSession.ts"],"sourcesContent":["/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger as rootLogger } from \"../logger.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { EventTimeline } from \"../models/event-timeline.ts\";\nimport { Room } from \"../models/room.ts\";\nimport { MatrixClient } from \"../client.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { UpdateDelayedEventAction } from \"../@types/requests.ts\";\nimport {\n    CallMembership,\n    CallMembershipData,\n    CallMembershipDataLegacy,\n    SessionMembershipData,\n    isLegacyCallMembershipData,\n} from \"./CallMembership.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { Focus } from \"./focus.ts\";\nimport { randomString, secureRandomBase64Url } from \"../randomstring.ts\";\nimport { EncryptionKeysEventContent } from \"./types.ts\";\nimport { decodeBase64, encodeUnpaddedBase64 } from \"../base64.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\nimport { MatrixError } from \"../http-api/errors.ts\";\nimport { MatrixEvent } from \"../models/event.ts\";\nimport { isLivekitFocusActive } from \"./LivekitFocus.ts\";\nimport { ExperimentalGroupCallRoomMemberState } from \"../webrtc/groupCall.ts\";\n\nconst logger = rootLogger.getChild(\"MatrixRTCSession\");\n\nconst MEMBERSHIP_EXPIRY_TIME = 60 * 60 * 1000;\nconst MEMBER_EVENT_CHECK_PERIOD = 2 * 60 * 1000; // How often we check to see if we need to re-send our member event\nconst CALL_MEMBER_EVENT_RETRY_DELAY_MIN = 3000;\nconst UPDATE_ENCRYPTION_KEY_THROTTLE = 3000;\n\n// A delay after a member leaves before we create and publish a new key, because people\n// tend to leave calls at the same time\nconst MAKE_KEY_DELAY = 3000;\n// The delay between creating and sending a new key and starting to encrypt with it. This gives others\n// a chance to receive the new key to minimise the chance they don't get media they can't decrypt.\n// The total time between a member leaving and the call switching to new keys is therefore\n// MAKE_KEY_DELAY + SEND_KEY_DELAY\nconst USE_KEY_DELAY = 5000;\n\nconst getParticipantId = (userId: string, deviceId: string): string => `${userId}:${deviceId}`;\nconst getParticipantIdFromMembership = (m: CallMembership): string => getParticipantId(m.sender!, m.deviceId);\n\nfunction keysEqual(a: Uint8Array | undefined, b: Uint8Array | undefined): boolean {\n    if (a === b) return true;\n    return !!a && !!b && a.length === b.length && a.every((x, i) => x === b[i]);\n}\n\nexport enum MatrixRTCSessionEvent {\n    // A member joined, left, or updated a property of their membership.\n    MembershipsChanged = \"memberships_changed\",\n    // We joined or left the session: our own local idea of whether we are joined,\n    // separate from MembershipsChanged, ie. independent of whether our member event\n    // has successfully gone through.\n    JoinStateChanged = \"join_state_changed\",\n    // The key used to encrypt media has changed\n    EncryptionKeyChanged = \"encryption_key_changed\",\n}\n\nexport type MatrixRTCSessionEventHandlerMap = {\n    [MatrixRTCSessionEvent.MembershipsChanged]: (\n        oldMemberships: CallMembership[],\n        newMemberships: CallMembership[],\n    ) => void;\n    [MatrixRTCSessionEvent.JoinStateChanged]: (isJoined: boolean) => void;\n    [MatrixRTCSessionEvent.EncryptionKeyChanged]: (\n        key: Uint8Array,\n        encryptionKeyIndex: number,\n        participantId: string,\n    ) => void;\n};\nexport interface JoinSessionConfig {\n    /** If true, generate and share a media key for this participant,\n     *  and emit MatrixRTCSessionEvent.EncryptionKeyChanged when\n     *  media keys for other participants become available.\n     */\n    manageMediaKeys?: boolean;\n    /** Lets you configure how the events for the session are formatted.\n     *   - legacy: use one event with a membership array.\n     *   - MSC4143: use one event per membership (with only one membership per event)\n     * More details can be found in MSC4143 and by checking the types:\n     * `CallMembershipDataLegacy` and `SessionMembershipData`\n     */\n    useLegacyMemberEvents?: boolean;\n}\n/**\n * A MatrixRTCSession manages the membership & properties of a MatrixRTC session.\n * This class doesn't deal with media at all, just membership & properties of a session.\n */\nexport class MatrixRTCSession extends TypedEventEmitter<MatrixRTCSessionEvent, MatrixRTCSessionEventHandlerMap> {\n    // The session Id of the call, this is the call_id of the call Member event.\n    private _callId: string | undefined;\n\n    // How many ms after we joined the call, that our membership should expire, or undefined\n    // if we're not yet joined\n    private relativeExpiry: number | undefined;\n\n    // An identifier for our membership of the call. This will allow us to easily recognise\n    // whether a membership was sent by this session or is stale from some other time.\n    // It also forces our membership events to be unique, because otherwise we could try\n    // to overwrite a membership from a previous session but it would do nothing because the\n    // event content would be identical. We need the origin_server_ts to update though, so\n    // forcing unique content fixes this.\n    private membershipId: string | undefined;\n\n    private memberEventTimeout?: ReturnType<typeof setTimeout>;\n    private expiryTimeout?: ReturnType<typeof setTimeout>;\n    private keysEventUpdateTimeout?: ReturnType<typeof setTimeout>;\n    private makeNewKeyTimeout?: ReturnType<typeof setTimeout>;\n    private setNewKeyTimeouts = new Set<ReturnType<typeof setTimeout>>();\n\n    // This is a Focus with the specified fields for an ActiveFocus (e.g. LivekitFocusActive for type=\"livekit\")\n    private ownFocusActive?: Focus;\n    // This is a Foci array that contains the Focus objects this user is aware of and proposes to use.\n    private ownFociPreferred?: Focus[];\n\n    private updateCallMembershipRunning = false;\n    private needCallMembershipUpdate = false;\n\n    private manageMediaKeys = false;\n    private useLegacyMemberEvents = true;\n    // userId:deviceId => array of (key, timestamp)\n    private encryptionKeys = new Map<string, Array<{ key: Uint8Array; timestamp: number }>>();\n    private lastEncryptionKeyUpdateRequest?: number;\n\n    // We use this to store the last membership fingerprints we saw, so we can proactively re-send encryption keys\n    // if it looks like a membership has been updated.\n    private lastMembershipFingerprints: Set<string> | undefined;\n\n    /**\n     * The callId (sessionId) of the call.\n     *\n     * It can be undefined since the callId is only known once the first membership joins.\n     * The callId is the property that, per definition, groups memberships into one call.\n     */\n    public get callId(): string | undefined {\n        return this._callId;\n    }\n    /**\n     * Returns all the call memberships for a room, oldest first\n     */\n    public static callMembershipsForRoom(room: Room): CallMembership[] {\n        const roomState = room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) {\n            logger.warn(\"Couldn't get state for room \" + room.roomId);\n            throw new Error(\"Could't get state for room \" + room.roomId);\n        }\n        const callMemberEvents = roomState.getStateEvents(EventType.GroupCallMemberPrefix);\n\n        const callMemberships: CallMembership[] = [];\n        for (const memberEvent of callMemberEvents) {\n            const content = memberEvent.getContent();\n            const eventKeysCount = Object.keys(content).length;\n            // Dont even bother about empty events (saves us from costly type/\"key in\" checks in bigger rooms)\n            if (eventKeysCount === 0) continue;\n\n            let membershipContents: any[] = [];\n\n            // We first decide if its a MSC4143 event (per device state key)\n            if (eventKeysCount > 1 && \"focus_active\" in content) {\n                // We have a MSC4143 event membership event\n                membershipContents.push(content);\n            } else if (eventKeysCount === 1 && \"memberships\" in content) {\n                // we have a legacy (one event for all devices) event\n                if (!Array.isArray(content[\"memberships\"])) {\n                    logger.warn(`Malformed member event from ${memberEvent.getSender()}: memberships is not an array`);\n                    continue;\n                }\n                membershipContents = content[\"memberships\"];\n            }\n\n            if (membershipContents.length === 0) continue;\n\n            for (const membershipData of membershipContents) {\n                try {\n                    const membership = new CallMembership(memberEvent, membershipData);\n\n                    if (membership.callId !== \"\" || membership.scope !== \"m.room\") {\n                        // for now, just ignore anything that isn't a room scope call\n                        logger.info(`Ignoring user-scoped call`);\n                        continue;\n                    }\n\n                    if (membership.isExpired()) {\n                        logger.info(`Ignoring expired device membership ${membership.sender}/${membership.deviceId}`);\n                        continue;\n                    }\n                    if (!room.hasMembershipState(membership.sender ?? \"\", KnownMembership.Join)) {\n                        logger.info(`Ignoring membership of user ${membership.sender} who is not in the room.`);\n                        continue;\n                    }\n                    callMemberships.push(membership);\n                } catch (e) {\n                    logger.warn(\"Couldn't construct call membership: \", e);\n                }\n            }\n        }\n\n        callMemberships.sort((a, b) => a.createdTs() - b.createdTs());\n        if (callMemberships.length > 1) {\n            logger.debug(\n                `Call memberships in room ${room.roomId}, in order: `,\n                callMemberships.map((m) => [m.createdTs(), m.sender]),\n            );\n        }\n\n        return callMemberships;\n    }\n\n    /**\n     * Return the MatrixRTC session for the room, whether there are currently active members or not\n     */\n    public static roomSessionForRoom(client: MatrixClient, room: Room): MatrixRTCSession {\n        const callMemberships = MatrixRTCSession.callMembershipsForRoom(room);\n\n        return new MatrixRTCSession(client, room, callMemberships);\n    }\n\n    private constructor(\n        private readonly client: MatrixClient,\n        public readonly room: Room,\n        public memberships: CallMembership[],\n    ) {\n        super();\n        this._callId = memberships[0]?.callId;\n        const roomState = this.room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        roomState?.on(RoomStateEvent.Members, this.onMembershipUpdate);\n        this.setExpiryTimer();\n    }\n\n    /*\n     * Returns true if we intend to be participating in the MatrixRTC session.\n     * This is determined by checking if the relativeExpiry has been set.\n     */\n    public isJoined(): boolean {\n        return this.relativeExpiry !== undefined;\n    }\n\n    /**\n     * Performs cleanup & removes timers for client shutdown\n     */\n    public async stop(): Promise<void> {\n        await this.leaveRoomSession(1000);\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n        if (this.memberEventTimeout) {\n            clearTimeout(this.memberEventTimeout);\n            this.memberEventTimeout = undefined;\n        }\n        const roomState = this.room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        roomState?.off(RoomStateEvent.Members, this.onMembershipUpdate);\n    }\n\n    /**\n     * Announces this user and device as joined to the MatrixRTC session,\n     * and continues to update the membership event to keep it valid until\n     * leaveRoomSession() is called\n     * This will not subscribe to updates: remember to call subscribe() separately if\n     * desired.\n     * This method will return immediately and the session will be joined in the background.\n     *\n     * @param fociActive - The object representing the active focus. (This depends on the focus type.)\n     * @param fociPreferred - The list of preferred foci this member proposes to use/knows/has access to.\n     *                        For the livekit case this is a list of foci generated from the homeserver well-known, the current rtc session,\n     *                        or optionally other room members homeserver well known.\n     * @param joinConfig - Additional configuration for the joined session.\n     */\n    public joinRoomSession(fociPreferred: Focus[], fociActive?: Focus, joinConfig?: JoinSessionConfig): void {\n        if (this.isJoined()) {\n            logger.info(`Already joined to session in room ${this.room.roomId}: ignoring join call`);\n            return;\n        }\n\n        this.ownFocusActive = fociActive;\n        this.ownFociPreferred = fociPreferred;\n        this.relativeExpiry = MEMBERSHIP_EXPIRY_TIME;\n        this.manageMediaKeys = joinConfig?.manageMediaKeys ?? this.manageMediaKeys;\n        this.useLegacyMemberEvents = joinConfig?.useLegacyMemberEvents ?? this.useLegacyMemberEvents;\n        this.membershipId = randomString(5);\n\n        logger.info(`Joining call session in room ${this.room.roomId} with manageMediaKeys=${this.manageMediaKeys}`);\n        if (joinConfig?.manageMediaKeys) {\n            this.makeNewSenderKey();\n            this.requestKeyEventSend();\n        }\n        // We don't wait for this, mostly because it may fail and schedule a retry, so this\n        // function returning doesn't really mean anything at all.\n        this.triggerCallMembershipEventUpdate();\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, true);\n    }\n\n    /**\n     * Announces this user and device as having left the MatrixRTC session\n     * and stops scheduled updates.\n     * This will not unsubscribe from updates: remember to call unsubscribe() separately if\n     * desired.\n     * The membership update required to leave the session will retry if it fails.\n     * Without network connection the promise will never resolve.\n     * A timeout can be provided so that there is a guarantee for the promise to resolve.\n     */\n    public async leaveRoomSession(timeout: number | undefined = undefined): Promise<boolean> {\n        if (!this.isJoined()) {\n            logger.info(`Not joined to session in room ${this.room.roomId}: ignoring leave call`);\n            return new Promise((resolve) => resolve(false));\n        }\n\n        const userId = this.client.getUserId();\n        const deviceId = this.client.getDeviceId();\n\n        if (!userId) throw new Error(\"No userId\");\n        if (!deviceId) throw new Error(\"No deviceId\");\n\n        // clear our encryption keys as we're done with them now (we'll\n        // make new keys if we rejoin). We leave keys for other participants\n        // as they may still be using the same ones.\n        this.encryptionKeys.set(getParticipantId(userId, deviceId), []);\n\n        if (this.makeNewKeyTimeout !== undefined) {\n            clearTimeout(this.makeNewKeyTimeout);\n            this.makeNewKeyTimeout = undefined;\n        }\n        for (const t of this.setNewKeyTimeouts) {\n            clearTimeout(t);\n        }\n        this.setNewKeyTimeouts.clear();\n\n        logger.info(`Leaving call session in room ${this.room.roomId}`);\n        this.relativeExpiry = undefined;\n        this.ownFocusActive = undefined;\n        this.manageMediaKeys = false;\n        this.membershipId = undefined;\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, false);\n\n        const timeoutPromise = new Promise((r) => {\n            if (timeout) {\n                // will never resolve if timeout is not set\n                setTimeout(r, timeout, \"timeout\");\n            }\n        });\n        return new Promise((resolve) => {\n            Promise.race([this.triggerCallMembershipEventUpdate(), timeoutPromise]).then((value) => {\n                // The timeoutPromise returns the string 'timeout' and the membership update void\n                // A success implies that the membership update was quicker then the timeout.\n                resolve(value != \"timeout\");\n            });\n        });\n    }\n\n    public getActiveFocus(): Focus | undefined {\n        if (this.ownFocusActive && isLivekitFocusActive(this.ownFocusActive)) {\n            // A livekit active focus\n            if (this.ownFocusActive.focus_selection === \"oldest_membership\") {\n                const oldestMembership = this.getOldestMembership();\n                return oldestMembership?.getPreferredFoci()[0];\n            }\n        }\n        if (!this.ownFocusActive) {\n            // we use the legacy call.member events so default to oldest member\n            const oldestMembership = this.getOldestMembership();\n            return oldestMembership?.getPreferredFoci()[0];\n        }\n    }\n\n    /**\n     * Get the known encryption keys for a given participant device.\n     *\n     * @param userId the user ID of the participant\n     * @param deviceId the device ID of the participant\n     * @returns The encryption keys for the given participant, or undefined if they are not known.\n     */\n    public getKeysForParticipant(userId: string, deviceId: string): Array<Uint8Array> | undefined {\n        return this.encryptionKeys.get(getParticipantId(userId, deviceId))?.map((entry) => entry.key);\n    }\n\n    /**\n     * A map of keys used to encrypt and decrypt (we are using a symmetric\n     * cipher) given participant's media. This also includes our own key\n     */\n    public getEncryptionKeys(): IterableIterator<[string, Array<Uint8Array>]> {\n        // the returned array doesn't contain the timestamps\n        return Array.from(this.encryptionKeys.entries())\n            .map(([participantId, keys]): [string, Uint8Array[]] => [participantId, keys.map((k) => k.key)])\n            .values();\n    }\n\n    private getNewEncryptionKeyIndex(): number {\n        const userId = this.client.getUserId();\n        const deviceId = this.client.getDeviceId();\n\n        if (!userId) throw new Error(\"No userId!\");\n        if (!deviceId) throw new Error(\"No deviceId!\");\n\n        return (this.getKeysForParticipant(userId, deviceId)?.length ?? 0) % 16;\n    }\n\n    /**\n     * Sets an encryption key at a specified index for a participant.\n     * The encryption keys for the local participant are also stored here under the\n     * user and device ID of the local participant.\n     * If the key is older than the existing key at the index, it will be ignored.\n     * @param userId - The user ID of the participant\n     * @param deviceId - Device ID of the participant\n     * @param encryptionKeyIndex - The index of the key to set\n     * @param encryptionKeyString - The string representation of the key to set in base64\n     * @param timestamp - The timestamp of the key. We assume that these are monotonic for each participant device.\n     * @param delayBeforeUse - If true, delay before emitting a key changed event. Useful when setting\n     *                         encryption keys for the local participant to allow time for the key to\n     *                         be distributed.\n     */\n    private setEncryptionKey(\n        userId: string,\n        deviceId: string,\n        encryptionKeyIndex: number,\n        encryptionKeyString: string,\n        timestamp: number,\n        delayBeforeUse = false,\n    ): void {\n        const keyBin = decodeBase64(encryptionKeyString);\n\n        const participantId = getParticipantId(userId, deviceId);\n        if (!this.encryptionKeys.has(participantId)) {\n            this.encryptionKeys.set(participantId, []);\n        }\n        const participantKeys = this.encryptionKeys.get(participantId)!;\n\n        const existingKeyAtIndex = participantKeys[encryptionKeyIndex];\n\n        if (existingKeyAtIndex) {\n            if (existingKeyAtIndex.timestamp > timestamp) {\n                logger.info(\n                    `Ignoring new key at index ${encryptionKeyIndex} for ${participantId} as it is older than existing known key`,\n                );\n                return;\n            }\n\n            if (keysEqual(existingKeyAtIndex.key, keyBin)) {\n                existingKeyAtIndex.timestamp = timestamp;\n                return;\n            }\n        }\n\n        participantKeys[encryptionKeyIndex] = {\n            key: keyBin,\n            timestamp,\n        };\n\n        if (delayBeforeUse) {\n            const useKeyTimeout = setTimeout(() => {\n                this.setNewKeyTimeouts.delete(useKeyTimeout);\n                logger.info(`Delayed-emitting key changed event for ${participantId} idx ${encryptionKeyIndex}`);\n                this.emit(MatrixRTCSessionEvent.EncryptionKeyChanged, keyBin, encryptionKeyIndex, participantId);\n            }, USE_KEY_DELAY);\n            this.setNewKeyTimeouts.add(useKeyTimeout);\n        } else {\n            this.emit(MatrixRTCSessionEvent.EncryptionKeyChanged, keyBin, encryptionKeyIndex, participantId);\n        }\n    }\n\n    /**\n     * Generate a new sender key and add it at the next available index\n     * @param delayBeforeUse - If true, wait for a short period before setting the key for the\n     *                         media encryptor to use. If false, set the key immediately.\n     */\n    private makeNewSenderKey(delayBeforeUse = false): void {\n        const userId = this.client.getUserId();\n        const deviceId = this.client.getDeviceId();\n\n        if (!userId) throw new Error(\"No userId\");\n        if (!deviceId) throw new Error(\"No deviceId\");\n\n        const encryptionKey = secureRandomBase64Url(16);\n        const encryptionKeyIndex = this.getNewEncryptionKeyIndex();\n        logger.info(\"Generated new key at index \" + encryptionKeyIndex);\n        this.setEncryptionKey(userId, deviceId, encryptionKeyIndex, encryptionKey, Date.now(), delayBeforeUse);\n    }\n\n    /**\n     * Requests that we resend our keys to the room. May send a keys event immediately\n     * or queue for alter if one has already been sent recently.\n     */\n    private requestKeyEventSend(): void {\n        if (!this.manageMediaKeys) return;\n\n        if (\n            this.lastEncryptionKeyUpdateRequest &&\n            this.lastEncryptionKeyUpdateRequest + UPDATE_ENCRYPTION_KEY_THROTTLE > Date.now()\n        ) {\n            logger.info(\"Last encryption key event sent too recently: postponing\");\n            if (this.keysEventUpdateTimeout === undefined) {\n                this.keysEventUpdateTimeout = setTimeout(this.sendEncryptionKeysEvent, UPDATE_ENCRYPTION_KEY_THROTTLE);\n            }\n            return;\n        }\n\n        this.sendEncryptionKeysEvent();\n    }\n\n    /**\n     * Re-sends the encryption keys room event\n     */\n    private sendEncryptionKeysEvent = async (): Promise<void> => {\n        if (this.keysEventUpdateTimeout !== undefined) {\n            clearTimeout(this.keysEventUpdateTimeout);\n            this.keysEventUpdateTimeout = undefined;\n        }\n        this.lastEncryptionKeyUpdateRequest = Date.now();\n\n        logger.info(\"Sending encryption keys event\");\n\n        if (!this.isJoined()) return;\n\n        const userId = this.client.getUserId();\n        const deviceId = this.client.getDeviceId();\n\n        if (!userId) throw new Error(\"No userId\");\n        if (!deviceId) throw new Error(\"No deviceId\");\n\n        const myKeys = this.getKeysForParticipant(userId, deviceId);\n\n        if (!myKeys) {\n            logger.warn(\"Tried to send encryption keys event but no keys found!\");\n            return;\n        }\n\n        try {\n            await this.client.sendEvent(this.room.roomId, EventType.CallEncryptionKeysPrefix, {\n                keys: myKeys.map((key, index) => {\n                    return {\n                        index,\n                        key: encodeUnpaddedBase64(key),\n                    };\n                }),\n                device_id: deviceId,\n                call_id: \"\",\n            } as EncryptionKeysEventContent);\n\n            logger.debug(\n                `Embedded-E2EE-LOG updateEncryptionKeyEvent participantId=${userId}:${deviceId} numSent=${myKeys.length}`,\n                this.encryptionKeys,\n            );\n        } catch (error) {\n            const matrixError = error as MatrixError;\n            if (matrixError.event) {\n                // cancel the pending event: we'll just generate a new one with our latest\n                // keys when we resend\n                this.client.cancelPendingEvent(matrixError.event);\n            }\n            if (this.keysEventUpdateTimeout === undefined) {\n                const resendDelay = matrixError.data?.retry_after_ms ?? 5000;\n                logger.warn(`Failed to send m.call.encryption_key, retrying in ${resendDelay}`, error);\n                this.keysEventUpdateTimeout = setTimeout(this.sendEncryptionKeysEvent, resendDelay);\n            } else {\n                logger.info(\"Not scheduling key resend as another re-send is already pending\");\n            }\n        }\n    };\n\n    /**\n     * Sets a timer for the soonest membership expiry\n     */\n    private setExpiryTimer(): void {\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n\n        let soonestExpiry;\n        for (const membership of this.memberships) {\n            const thisExpiry = membership.getMsUntilExpiry();\n            // If getMsUntilExpiry is undefined we have a MSC4143 (MatrixRTC) compliant event - it never expires\n            // but will be reliably resent on disconnect.\n            if (thisExpiry !== undefined && (soonestExpiry === undefined || thisExpiry < soonestExpiry)) {\n                soonestExpiry = thisExpiry;\n            }\n        }\n\n        if (soonestExpiry != undefined) {\n            this.expiryTimeout = setTimeout(this.onMembershipUpdate, soonestExpiry);\n        }\n    }\n\n    public getOldestMembership(): CallMembership | undefined {\n        return this.memberships[0];\n    }\n\n    public getFocusInUse(): Focus | undefined {\n        const oldestMembership = this.getOldestMembership();\n        if (oldestMembership?.getFocusSelection() === \"oldest_membership\") {\n            return oldestMembership.getPreferredFoci()[0];\n        }\n    }\n\n    /**\n     * Process `m.call.encryption_keys` events to track the encryption keys for call participants.\n     * This should be called each time the relevant event is received from a room timeline.\n     * If the event is malformed then it will be logged and ignored.\n     *\n     * @param event the event to process\n     */\n    public onCallEncryption = (event: MatrixEvent): void => {\n        const userId = event.getSender();\n        const content = event.getContent<EncryptionKeysEventContent>();\n\n        const deviceId = content[\"device_id\"];\n        const callId = content[\"call_id\"];\n\n        if (!userId) {\n            logger.warn(`Received m.call.encryption_keys with no userId: callId=${callId}`);\n            return;\n        }\n\n        // We currently only handle callId = \"\" (which is the default for room scoped calls)\n        if (callId !== \"\") {\n            logger.warn(\n                `Received m.call.encryption_keys with unsupported callId: userId=${userId}, deviceId=${deviceId}, callId=${callId}`,\n            );\n            return;\n        }\n\n        if (!Array.isArray(content.keys)) {\n            logger.warn(`Received m.call.encryption_keys where keys wasn't an array: callId=${callId}`);\n            return;\n        }\n\n        if (userId === this.client.getUserId() && deviceId === this.client.getDeviceId()) {\n            // We store our own sender key in the same set along with keys from others, so it's\n            // important we don't allow our own keys to be set by one of these events (apart from\n            // the fact that we don't need it anyway because we already know our own keys).\n            logger.info(\"Ignoring our own keys event\");\n            return;\n        }\n\n        for (const key of content.keys) {\n            if (!key) {\n                logger.info(\"Ignoring false-y key in keys event\");\n                continue;\n            }\n\n            const encryptionKey = key.key;\n            const encryptionKeyIndex = key.index;\n\n            if (\n                !encryptionKey ||\n                encryptionKeyIndex === undefined ||\n                encryptionKeyIndex === null ||\n                callId === undefined ||\n                callId === null ||\n                typeof deviceId !== \"string\" ||\n                typeof callId !== \"string\" ||\n                typeof encryptionKey !== \"string\" ||\n                typeof encryptionKeyIndex !== \"number\"\n            ) {\n                logger.warn(\n                    `Malformed call encryption_key: userId=${userId}, deviceId=${deviceId}, encryptionKeyIndex=${encryptionKeyIndex} callId=${callId}`,\n                );\n            } else {\n                logger.debug(\n                    `Embedded-E2EE-LOG onCallEncryption userId=${userId}:${deviceId} encryptionKeyIndex=${encryptionKeyIndex}`,\n                    this.encryptionKeys,\n                );\n                this.setEncryptionKey(userId, deviceId, encryptionKeyIndex, encryptionKey, event.getTs());\n            }\n        }\n    };\n\n    private isMyMembership = (m: CallMembership): boolean =>\n        m.sender === this.client.getUserId() && m.deviceId === this.client.getDeviceId();\n\n    /**\n     * Examines the latest call memberships and handles any encryption key sending or rotation that is needed.\n     *\n     * This function should be called when the room members or call memberships might have changed.\n     */\n    public onMembershipUpdate = (): void => {\n        const oldMemberships = this.memberships;\n        this.memberships = MatrixRTCSession.callMembershipsForRoom(this.room);\n\n        this._callId = this._callId ?? this.memberships[0]?.callId;\n\n        const changed =\n            oldMemberships.length != this.memberships.length ||\n            oldMemberships.some((m, i) => !CallMembership.equal(m, this.memberships[i]));\n\n        if (changed) {\n            logger.info(`Memberships for call in room ${this.room.roomId} have changed: emitting`);\n            this.emit(MatrixRTCSessionEvent.MembershipsChanged, oldMemberships, this.memberships);\n        }\n\n        if (this.manageMediaKeys && this.isJoined() && this.makeNewKeyTimeout === undefined) {\n            const oldMembershipIds = new Set(\n                oldMemberships.filter((m) => !this.isMyMembership(m)).map(getParticipantIdFromMembership),\n            );\n            const newMembershipIds = new Set(\n                this.memberships.filter((m) => !this.isMyMembership(m)).map(getParticipantIdFromMembership),\n            );\n\n            // We can use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference\n            // for this once available\n            const anyLeft = Array.from(oldMembershipIds).some((x) => !newMembershipIds.has(x));\n            const anyJoined = Array.from(newMembershipIds).some((x) => !oldMembershipIds.has(x));\n\n            const oldFingerprints = this.lastMembershipFingerprints;\n            // always store the fingerprints of these latest memberships\n            this.storeLastMembershipFingerprints();\n\n            if (anyLeft) {\n                logger.debug(`Member(s) have left: queueing sender key rotation`);\n                this.makeNewKeyTimeout = setTimeout(this.onRotateKeyTimeout, MAKE_KEY_DELAY);\n            } else if (anyJoined) {\n                logger.debug(`New member(s) have joined: re-sending keys`);\n                this.requestKeyEventSend();\n            } else if (oldFingerprints) {\n                // does it look like any of the members have updated their memberships?\n                const newFingerprints = this.lastMembershipFingerprints!;\n\n                // We can use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference\n                // for this once available\n                const candidateUpdates =\n                    Array.from(oldFingerprints).some((x) => !newFingerprints.has(x)) ||\n                    Array.from(newFingerprints).some((x) => !oldFingerprints.has(x));\n                if (candidateUpdates) {\n                    logger.debug(`Member(s) have updated/reconnected: re-sending keys`);\n                    this.requestKeyEventSend();\n                }\n            }\n        }\n\n        this.setExpiryTimer();\n    };\n\n    private storeLastMembershipFingerprints(): void {\n        this.lastMembershipFingerprints = new Set(\n            this.memberships\n                .filter((m) => !this.isMyMembership(m))\n                .map((m) => `${getParticipantIdFromMembership(m)}:${m.membershipID}:${m.createdTs()}`),\n        );\n    }\n\n    /**\n     * Constructs our own membership\n     * @param prevMembership - The previous value of our call membership, if any\n     */\n    private makeMyMembershipLegacy(deviceId: string, prevMembership?: CallMembership): CallMembershipDataLegacy {\n        if (this.relativeExpiry === undefined) {\n            throw new Error(\"Tried to create our own membership event when we're not joined!\");\n        }\n        if (this.membershipId === undefined) {\n            throw new Error(\"Tried to create our own membership event when we have no membership ID!\");\n        }\n        const createdTs = prevMembership?.createdTs();\n        return {\n            call_id: \"\",\n            scope: \"m.room\",\n            application: \"m.call\",\n            device_id: deviceId,\n            expires: this.relativeExpiry,\n            // TODO: Date.now() should be the origin_server_ts (now).\n            expires_ts: this.relativeExpiry + (createdTs ?? Date.now()),\n            // we use the fociPreferred since this is the list of foci.\n            // it is named wrong in the Legacy events.\n            foci_active: this.ownFociPreferred,\n            membershipID: this.membershipId,\n            ...(createdTs ? { created_ts: createdTs } : {}),\n        };\n    }\n    /**\n     * Constructs our own membership\n     */\n    private makeMyMembership(deviceId: string): SessionMembershipData {\n        return {\n            call_id: \"\",\n            scope: \"m.room\",\n            application: \"m.call\",\n            device_id: deviceId,\n            focus_active: { type: \"livekit\", focus_selection: \"oldest_membership\" },\n            foci_preferred: this.ownFociPreferred ?? [],\n        };\n    }\n\n    /**\n     * Returns true if our membership event needs to be updated\n     */\n    private membershipEventNeedsUpdate(\n        myPrevMembershipData?: CallMembershipData,\n        myPrevMembership?: CallMembership,\n    ): boolean {\n        if (myPrevMembership && myPrevMembership.getMsUntilExpiry() === undefined) return false;\n\n        // Need to update if there's a membership for us but we're not joined (valid or otherwise)\n        if (!this.isJoined()) return !!myPrevMembershipData;\n\n        // ...or if we are joined, but there's no valid membership event\n        if (!myPrevMembership) return true;\n\n        const expiryTime = myPrevMembership.getMsUntilExpiry();\n        if (expiryTime !== undefined && expiryTime < MEMBERSHIP_EXPIRY_TIME / 2) {\n            // ...or if the expiry time needs bumping\n            this.relativeExpiry! += MEMBERSHIP_EXPIRY_TIME;\n            return true;\n        }\n\n        return false;\n    }\n\n    private makeNewMembership(deviceId: string): SessionMembershipData | {} {\n        // If we're joined, add our own\n        if (this.isJoined()) {\n            return this.makeMyMembership(deviceId);\n        }\n        return {};\n    }\n    /**\n     * Makes a new membership list given the old list alonng with this user's previous membership event\n     * (if any) and this device's previous membership (if any)\n     */\n    private makeNewLegacyMemberships(\n        oldMemberships: CallMembershipData[],\n        localDeviceId: string,\n        myCallMemberEvent?: MatrixEvent,\n        myPrevMembership?: CallMembership,\n    ): ExperimentalGroupCallRoomMemberState {\n        const filterExpired = (m: CallMembershipData): boolean => {\n            let membershipObj;\n            try {\n                membershipObj = new CallMembership(myCallMemberEvent!, m);\n            } catch (e) {\n                return false;\n            }\n\n            return !membershipObj.isExpired();\n        };\n\n        const transformMemberships = (m: CallMembershipData): CallMembershipData => {\n            if (m.created_ts === undefined) {\n                // we need to fill this in with the origin_server_ts from its original event\n                m.created_ts = myCallMemberEvent!.getTs();\n            }\n\n            return m;\n        };\n\n        // Filter our any invalid or expired memberships, and also our own - we'll add that back in next\n        let newMemberships = oldMemberships.filter(filterExpired).filter((m) => m.device_id !== localDeviceId);\n\n        // Fix up any memberships that need their created_ts adding\n        newMemberships = newMemberships.map(transformMemberships);\n\n        // If we're joined, add our own\n        if (this.isJoined()) {\n            newMemberships.push(this.makeMyMembershipLegacy(localDeviceId, myPrevMembership));\n        }\n\n        return { memberships: newMemberships };\n    }\n\n    private triggerCallMembershipEventUpdate = async (): Promise<void> => {\n        if (this.updateCallMembershipRunning) {\n            this.needCallMembershipUpdate = true;\n            return;\n        }\n\n        this.updateCallMembershipRunning = true;\n        try {\n            // if anything triggers an update while the update is running, do another update afterwards\n            do {\n                this.needCallMembershipUpdate = false;\n                await this.updateCallMembershipEvent();\n            } while (this.needCallMembershipUpdate);\n        } finally {\n            this.updateCallMembershipRunning = false;\n        }\n    };\n\n    private async updateCallMembershipEvent(): Promise<void> {\n        if (this.memberEventTimeout) {\n            clearTimeout(this.memberEventTimeout);\n            this.memberEventTimeout = undefined;\n        }\n\n        const roomState = this.room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) throw new Error(\"Couldn't get room state for room \" + this.room.roomId);\n\n        const localUserId = this.client.getUserId();\n        const localDeviceId = this.client.getDeviceId();\n        if (!localUserId || !localDeviceId) throw new Error(\"User ID or device ID was null!\");\n\n        const callMemberEvents = roomState.events.get(EventType.GroupCallMemberPrefix);\n        const legacy = this.stateEventsContainOngoingLegacySession(callMemberEvents);\n        let newContent: {} | ExperimentalGroupCallRoomMemberState | SessionMembershipData = {};\n        if (legacy) {\n            const myCallMemberEvent = callMemberEvents?.get(localUserId);\n            const content = myCallMemberEvent?.getContent() ?? {};\n            let myPrevMembership: CallMembership | undefined;\n            // We know its CallMembershipDataLegacy\n            const memberships: CallMembershipDataLegacy[] = Array.isArray(content[\"memberships\"])\n                ? content[\"memberships\"]\n                : [];\n            const myPrevMembershipData = memberships.find((m) => m.device_id === localDeviceId);\n            try {\n                if (\n                    myCallMemberEvent &&\n                    myPrevMembershipData &&\n                    isLegacyCallMembershipData(myPrevMembershipData) &&\n                    myPrevMembershipData.membershipID === this.membershipId\n                ) {\n                    myPrevMembership = new CallMembership(myCallMemberEvent, myPrevMembershipData);\n                }\n            } catch (e) {\n                // This would indicate a bug or something weird if our own call membership\n                // wasn't valid\n                logger.warn(\"Our previous call membership was invalid - this shouldn't happen.\", e);\n            }\n            if (myPrevMembership) {\n                logger.debug(`${myPrevMembership.getMsUntilExpiry()} until our membership expires`);\n            }\n            if (!this.membershipEventNeedsUpdate(myPrevMembershipData, myPrevMembership)) {\n                // nothing to do - reschedule the check again\n                this.memberEventTimeout = setTimeout(this.triggerCallMembershipEventUpdate, MEMBER_EVENT_CHECK_PERIOD);\n                return;\n            }\n            newContent = this.makeNewLegacyMemberships(memberships, localDeviceId, myCallMemberEvent, myPrevMembership);\n        } else {\n            newContent = this.makeNewMembership(localDeviceId);\n        }\n\n        const stateKey = legacy ? localUserId : this.makeMembershipStateKey(localUserId, localDeviceId);\n        try {\n            await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallMemberPrefix, newContent, stateKey);\n            logger.info(`Sent updated call member event.`);\n\n            // check periodically to see if we need to refresh our member event\n            if (this.isJoined()) {\n                if (legacy) {\n                    this.memberEventTimeout = setTimeout(\n                        this.triggerCallMembershipEventUpdate,\n                        MEMBER_EVENT_CHECK_PERIOD,\n                    );\n                } else {\n                    try {\n                        // TODO: If delayed event times out, re-join!\n                        const res = await this.client._unstable_sendDelayedStateEvent(\n                            this.room.roomId,\n                            {\n                                delay: 8000,\n                            },\n                            EventType.GroupCallMemberPrefix,\n                            {}, // leave event\n                            stateKey,\n                        );\n                        this.scheduleDelayDisconnection(res.delay_id);\n                    } catch (e) {\n                        logger.error(\"Failed to send delayed event:\", e);\n                    }\n                }\n            }\n        } catch (e) {\n            const resendDelay = CALL_MEMBER_EVENT_RETRY_DELAY_MIN + Math.random() * 2000;\n            logger.warn(`Failed to send call member event (retrying in ${resendDelay}): ${e}`);\n            await new Promise((resolve) => setTimeout(resolve, resendDelay));\n            await this.triggerCallMembershipEventUpdate();\n        }\n    }\n\n    private scheduleDelayDisconnection(delayId: string): void {\n        this.memberEventTimeout = setTimeout(() => this.delayDisconnection(delayId), 5000);\n    }\n\n    private async delayDisconnection(delayId: string): Promise<void> {\n        try {\n            await this.client._unstable_updateDelayedEvent(delayId, UpdateDelayedEventAction.Restart);\n            this.scheduleDelayDisconnection(delayId);\n        } catch (e) {\n            logger.error(\"Failed to delay our disconnection event\", e);\n        }\n    }\n\n    private stateEventsContainOngoingLegacySession(callMemberEvents: Map<string, MatrixEvent> | undefined): boolean {\n        if (!callMemberEvents?.size) {\n            return this.useLegacyMemberEvents;\n        }\n\n        let containsAnyOngoingSession = false;\n        let containsUnknownOngoingSession = false;\n        for (const callMemberEvent of callMemberEvents.values()) {\n            const content = callMemberEvent.getContent();\n            if (Array.isArray(content[\"memberships\"])) {\n                for (const membership of content.memberships) {\n                    if (!new CallMembership(callMemberEvent, membership).isExpired()) {\n                        return true;\n                    }\n                }\n            } else if (Object.keys(content).length > 0) {\n                containsAnyOngoingSession ||= true;\n                containsUnknownOngoingSession ||= !(\"focus_active\" in content);\n            }\n        }\n        return containsAnyOngoingSession && !containsUnknownOngoingSession ? false : this.useLegacyMemberEvents;\n    }\n\n    private makeMembershipStateKey(localUserId: string, localDeviceId: string): string {\n        const stateKey = `${localUserId}_${localDeviceId}`;\n        if (/^org\\.matrix\\.msc(3757|3779)\\b/.exec(this.room.getVersion())) {\n            return stateKey;\n        } else {\n            return `_${stateKey}`;\n        }\n    }\n\n    private onRotateKeyTimeout = (): void => {\n        if (!this.manageMediaKeys) return;\n\n        this.makeNewKeyTimeout = undefined;\n        logger.info(\"Making new sender key for key rotation\");\n        this.makeNewSenderKey(true);\n        // send immediately: if we're about to start sending with a new key, it's\n        // important we get it out to others as soon as we can.\n        this.sendEncryptionKeysEvent();\n    };\n}\n"],"mappings":"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","ignoreList":[]}