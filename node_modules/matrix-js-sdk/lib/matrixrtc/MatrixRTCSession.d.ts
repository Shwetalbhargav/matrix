import { TypedEventEmitter } from "../models/typed-event-emitter.ts";
import { Room } from "../models/room.ts";
import { MatrixClient } from "../client.ts";
import { CallMembership } from "./CallMembership.ts";
import { Focus } from "./focus.ts";
import { MatrixEvent } from "../models/event.ts";
export declare enum MatrixRTCSessionEvent {
    MembershipsChanged = "memberships_changed",
    JoinStateChanged = "join_state_changed",
    EncryptionKeyChanged = "encryption_key_changed"
}
export type MatrixRTCSessionEventHandlerMap = {
    [MatrixRTCSessionEvent.MembershipsChanged]: (oldMemberships: CallMembership[], newMemberships: CallMembership[]) => void;
    [MatrixRTCSessionEvent.JoinStateChanged]: (isJoined: boolean) => void;
    [MatrixRTCSessionEvent.EncryptionKeyChanged]: (key: Uint8Array, encryptionKeyIndex: number, participantId: string) => void;
};
export interface JoinSessionConfig {
    /** If true, generate and share a media key for this participant,
     *  and emit MatrixRTCSessionEvent.EncryptionKeyChanged when
     *  media keys for other participants become available.
     */
    manageMediaKeys?: boolean;
    /** Lets you configure how the events for the session are formatted.
     *   - legacy: use one event with a membership array.
     *   - MSC4143: use one event per membership (with only one membership per event)
     * More details can be found in MSC4143 and by checking the types:
     * `CallMembershipDataLegacy` and `SessionMembershipData`
     */
    useLegacyMemberEvents?: boolean;
}
/**
 * A MatrixRTCSession manages the membership & properties of a MatrixRTC session.
 * This class doesn't deal with media at all, just membership & properties of a session.
 */
export declare class MatrixRTCSession extends TypedEventEmitter<MatrixRTCSessionEvent, MatrixRTCSessionEventHandlerMap> {
    private readonly client;
    readonly room: Room;
    memberships: CallMembership[];
    private _callId;
    private relativeExpiry;
    private membershipId;
    private memberEventTimeout?;
    private expiryTimeout?;
    private keysEventUpdateTimeout?;
    private makeNewKeyTimeout?;
    private setNewKeyTimeouts;
    private ownFocusActive?;
    private ownFociPreferred?;
    private updateCallMembershipRunning;
    private needCallMembershipUpdate;
    private manageMediaKeys;
    private useLegacyMemberEvents;
    private encryptionKeys;
    private lastEncryptionKeyUpdateRequest?;
    private lastMembershipFingerprints;
    /**
     * The callId (sessionId) of the call.
     *
     * It can be undefined since the callId is only known once the first membership joins.
     * The callId is the property that, per definition, groups memberships into one call.
     */
    get callId(): string | undefined;
    /**
     * Returns all the call memberships for a room, oldest first
     */
    static callMembershipsForRoom(room: Room): CallMembership[];
    /**
     * Return the MatrixRTC session for the room, whether there are currently active members or not
     */
    static roomSessionForRoom(client: MatrixClient, room: Room): MatrixRTCSession;
    private constructor();
    isJoined(): boolean;
    /**
     * Performs cleanup & removes timers for client shutdown
     */
    stop(): Promise<void>;
    /**
     * Announces this user and device as joined to the MatrixRTC session,
     * and continues to update the membership event to keep it valid until
     * leaveRoomSession() is called
     * This will not subscribe to updates: remember to call subscribe() separately if
     * desired.
     * This method will return immediately and the session will be joined in the background.
     *
     * @param fociActive - The object representing the active focus. (This depends on the focus type.)
     * @param fociPreferred - The list of preferred foci this member proposes to use/knows/has access to.
     *                        For the livekit case this is a list of foci generated from the homeserver well-known, the current rtc session,
     *                        or optionally other room members homeserver well known.
     * @param joinConfig - Additional configuration for the joined session.
     */
    joinRoomSession(fociPreferred: Focus[], fociActive?: Focus, joinConfig?: JoinSessionConfig): void;
    /**
     * Announces this user and device as having left the MatrixRTC session
     * and stops scheduled updates.
     * This will not unsubscribe from updates: remember to call unsubscribe() separately if
     * desired.
     * The membership update required to leave the session will retry if it fails.
     * Without network connection the promise will never resolve.
     * A timeout can be provided so that there is a guarantee for the promise to resolve.
     */
    leaveRoomSession(timeout?: number | undefined): Promise<boolean>;
    getActiveFocus(): Focus | undefined;
    /**
     * Get the known encryption keys for a given participant device.
     *
     * @param userId the user ID of the participant
     * @param deviceId the device ID of the participant
     * @returns The encryption keys for the given participant, or undefined if they are not known.
     */
    getKeysForParticipant(userId: string, deviceId: string): Array<Uint8Array> | undefined;
    /**
     * A map of keys used to encrypt and decrypt (we are using a symmetric
     * cipher) given participant's media. This also includes our own key
     */
    getEncryptionKeys(): IterableIterator<[string, Array<Uint8Array>]>;
    private getNewEncryptionKeyIndex;
    /**
     * Sets an encryption key at a specified index for a participant.
     * The encryption keys for the local participant are also stored here under the
     * user and device ID of the local participant.
     * If the key is older than the existing key at the index, it will be ignored.
     * @param userId - The user ID of the participant
     * @param deviceId - Device ID of the participant
     * @param encryptionKeyIndex - The index of the key to set
     * @param encryptionKeyString - The string representation of the key to set in base64
     * @param timestamp - The timestamp of the key. We assume that these are monotonic for each participant device.
     * @param delayBeforeUse - If true, delay before emitting a key changed event. Useful when setting
     *                         encryption keys for the local participant to allow time for the key to
     *                         be distributed.
     */
    private setEncryptionKey;
    /**
     * Generate a new sender key and add it at the next available index
     * @param delayBeforeUse - If true, wait for a short period before setting the key for the
     *                         media encryptor to use. If false, set the key immediately.
     */
    private makeNewSenderKey;
    /**
     * Requests that we resend our keys to the room. May send a keys event immediately
     * or queue for alter if one has already been sent recently.
     */
    private requestKeyEventSend;
    /**
     * Re-sends the encryption keys room event
     */
    private sendEncryptionKeysEvent;
    /**
     * Sets a timer for the soonest membership expiry
     */
    private setExpiryTimer;
    getOldestMembership(): CallMembership | undefined;
    getFocusInUse(): Focus | undefined;
    /**
     * Process `m.call.encryption_keys` events to track the encryption keys for call participants.
     * This should be called each time the relevant event is received from a room timeline.
     * If the event is malformed then it will be logged and ignored.
     *
     * @param event the event to process
     */
    onCallEncryption: (event: MatrixEvent) => void;
    private isMyMembership;
    /**
     * Examines the latest call memberships and handles any encryption key sending or rotation that is needed.
     *
     * This function should be called when the room members or call memberships might have changed.
     */
    onMembershipUpdate: () => void;
    private storeLastMembershipFingerprints;
    /**
     * Constructs our own membership
     * @param prevMembership - The previous value of our call membership, if any
     */
    private makeMyMembershipLegacy;
    /**
     * Constructs our own membership
     */
    private makeMyMembership;
    /**
     * Returns true if our membership event needs to be updated
     */
    private membershipEventNeedsUpdate;
    private makeNewMembership;
    /**
     * Makes a new membership list given the old list alonng with this user's previous membership event
     * (if any) and this device's previous membership (if any)
     */
    private makeNewLegacyMemberships;
    private triggerCallMembershipEventUpdate;
    private updateCallMembershipEvent;
    private scheduleDelayDisconnection;
    private delayDisconnection;
    private stateEventsContainOngoingLegacySession;
    private makeMembershipStateKey;
    private onRotateKeyTimeout;
}
//# sourceMappingURL=MatrixRTCSession.d.ts.map